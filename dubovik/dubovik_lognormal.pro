;+
 pro dubovik_lognormal, base_path, number_conc, rm, s, wn, ri, eps, dqv=dqv,  bext, bsca, w, g, ph, valid_eps=send_valid_eps, renorm_ph=rph, silent=silent, no_mie=no_mie
;
;
; Calculate scattering for distribution of spheroids with aspect ratios
; given by EPS. Data is obtained from look-up tables generated by Oleg
; Dubovik as described in Dubovik et al., JGRD v. 111 pg. D11208 (2006).
;
; Code should run interchangably with mie_lognormal, after adding EPS value
; between refractive index and output variables.
;
; To build up a distribution of EPS values simultaneously, use
; dubovik_lognormal_multiple_eps.pro which calls this routine multiple times.
;
; RANGE OF PARAMETERS:
;
;   RI - real : 22 values, 1.2914 -> 1.6964 with step of 0.01929
;   RI - imag : 15 values, 0.0005 -> 0.5000 by multiples of 0.61054
;   Size parameter: 41 values, 0.01198 -> 626.133 by multiples of 1.312
;   EPS : 25 values, 0.3349 -> 2.986 by multiples of 0.91286
;
; HISTORY:
;
;   AJAS (01/2010) Original version.
;   AJAS (07/2012) Header added.
;
;
;
; Andy Smith (smith@atm.ox.ac.uk)
;
;
;-


     valid_eps = [0.33490, 0.36690, 0.40190, 0.44030, 0.48230, 0.52830, $
                  0.57870, 0.63390, 0.69440, 0.76070, 0.83330, 0.91290, $
                  1.00000, 1.09540, 1.20000, 1.31450, 1.44000, 1.57740, $
                  1.72800, 1.89290, 2.07360, 2.27150, 2.48832, 2.72580, 2.98600]

     if arg_present(send_valid_eps) then begin
         send_valid_eps=valid_eps & nan=!values.f_nan
         dqv=nan & bext=nan & bsca=nan & w=nan & g=nan & ph=nan
         return
     endif


     ; Loud = 0 - no messages
     ; Loud = 1 - important messages
     ; Loud = 3 - all messages
     loud = KEYWORD_SET( silent ) ? silent[0] LE 1 : 3b

     if n_elements(eps) ne 1 then message,'EPS must be defined as a single element array'
     if imaginary(ri) gt 0 then message,'Imaginary part of RI must be negative'

     if eps eq 1.0 and ~ keyword_set(no_mie) then begin
         if loud gt 1 then message,/continue, $
           'Small spherical particles. Mie_lognormal is being called'
         mie_lognormal,number_conc,rm, s, wn, ri, dqv=dqv,/dlm,$
                       bext,bsca,w,g,ph
     endif else begin

         valid_eps_tol = 1e-5

         q = where((valid_eps - eps[0])^2 lt valid_eps_tol)
         if q[0] eq -1 then message,'EPS value is not valid - '+string(eps)

         file = base_path + '/ROUTINE/name.dat'
         dubovik_read_filenames, file, kext=file_kext, k11=file_k11

         path = base_path + '/KERNEL_n22_181/'
         dubovik_read_kernel_kext,         path+file_kext[q], dkext
         dubovik_read_kernel_scatt_matrix, path+file_k11[ q], dk11

         ; Interpolate our given from Dubovik RI to required value.
         ; Values of RI given by Dubovik tables
         n_dub =       dkext.ri_real
         ; Take log of k for even steps.
         kldub = alog(-dkext.ri_imag)

         ; The value of RI required
         n_me  =       double(   ri)
         klme  = alog(-imaginary(ri))

         if n_me gt max(n_dub) or n_me lt min(n_dub) then begin
           if loud then begin
             message,/continue,'Real RI is outside range of Dubovik tables.'
             print,'n =',n_me,', Range(n_dubovik) =',min(n_dub),max(n_dub)
           endif
         endif
         if klme gt max(kldub) or klme lt min(kldub) then begin
           if loud then begin
             message,/continue,'Imag RI is outside range of Dubovik tables.'
             print,'k =',-exp(klme),', Range(k_dubovik) =',-exp(max(kldub)),-exp(min(kldub))
           endif
         endif

         ; Reset onto a grid with step of 1 between points.
         grid_n_diff = n_dub[1] - n_dub[0]
         grid_k_diff = kldub[1] - kldub[0]

         ; Calculate where our value of RI lives on this new grid.
         grid_n      = (n_me - n_dub[0]) / grid_n_diff
         grid_k      = (klme - kldub[0]) / grid_k_diff

         ; Find the number of radii and angles used by Dubovik and
         ; prepare arrays to hold the interpolated tables.
         NR  = n_elements(dk11.radius )
         NT  = n_elements(dk11.theta  )

         KEXT_interp = dblarr(NR)
         KABS_interp = dblarr(NR)
         K11_interp  = dblarr(NR, NT)

         ; Interpolate
         for ir = 0, NR-1 do begin

             KEXT_interp[ir]  = interpolate(dkext.kext[*,*,ir], grid_n, grid_k)
             KABS_interp[ir]  = interpolate(dkext.kabs[*,*,ir], grid_n, grid_k)
             for it = 0, NT-1 do K11_interp[ir, it] = $
               interpolate(dk11.k11[*,*,ir,it], grid_n, grid_k)

         endfor

         ; Calculate the log normal distribution, dV / dlnr for the correct
         ; size parameter (using the wavelength given by the tables)
         rd   = dkext.radius
         rm_d = rm * dkext.wvl * wn

         distrb = number_conc * sqrt(8d0*!dpi)/3d0*rd^3/alog(S) * $
                       exp(-0.5d0*(alog(rd/rm_d) / alog(S)  )^2 )

         ; Multiply Text and Tabs by (k_old / k)^2 to correct for
         ; different value of radius actually used. n.b. This factor
         ; is dependant on lognormal distrib.
         Text = total(distrb * kext_interp) / (wn * dkext.wvl)^2
         Tabs = total(distrb * kabs_interp) / (wn * dkext.wvl)^2

         Tsca = Text - Tabs

         ph_dubovik = dblarr(NT)

         for it = 0, NT-1 do ph_dubovik[it] = total(distrb*K11_interp[*,it]) /$
                                        total(distrb*(kext_interp-kabs_interp))

         w     = Tsca / Text
         bext  = Text * 1e3
         bsca  = Tsca * 1e3

         theta = !dtor * dk11.theta
         sint  = sin(theta)
         cost  = cos(theta)

         gint0 = sint[0:nt-2] * cost[0:nt-2] * ph_dubovik[0:nt-2]
         gint1 = sint[1:nt-1] * cost[1:nt-1] * ph_dubovik[1:nt-1]
         dtheta= theta[1:nt-1] - theta[0:nt-2]
         g     = total((gint0+gint1)*dtheta) * 0.25

         ; Might have to interpolate angles from Dubovik grid onto different grid.
         if keyword_set(dqv) then begin
             if loud gt 1 and n_elements(dqv) gt NT then begin
                 message,/continue,$; Warn about interpolation
                     'Warning - Angular resolution of Dubovik data is 1 degree. Data will be interpolated.'
             endif

             ph = exp(interpol(alog(ph_dubovik), cos(theta), dqv,/lsquadratic))
             nd=n_elements(dqv)

             if nd gt nt then begin
                 sqv   = sqrt(1-dqv*dqv)
                 gint0 = sqv[0:nd-2]*dqv[0:nd-2]*ph[0:nd-2]
                 gint1 = sqv[1:nd-1]*dqv[1:nd-1]*ph[1:nd-1]
                 tt    = acos(dqv)
                 dt    = tt[1:nd-1] - tt[0:nd-2]

                 if ~ keyword_set(rph) then nnn = 1.0 else nnn = $
                   total((sqv[0:nd-2]*ph[0:nd-2]+sqv[1:nd-1]*ph[1:nd-1])*dt)/4.0

                 ph  = ph / nnn
                 g   = total((gint0+gint1)*dt) * 0.25 / nnn

             endif
         endif
     endelse
     return
end
